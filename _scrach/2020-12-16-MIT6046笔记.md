## unit2： 分治法 (divide and conquer)


### 快速傅里叶变换 (lecture 3)

整个算法的数学公式设计较多，学的不是很清楚。只能大致陈述一下思路。

快速傅里叶是一个运用分治法的计算机算法，复杂度为$O(nlgn)$，为了解决DFT（离散傅里叶）的数学问题。

#### 多项式乘法

如何用FFT来解决多项式的加法和乘法。一个多项式有多种表示方法，一种是系数：$A(x)=a_0+a_1x+a_2x^2+...+a_{n-1}x^{n-1}$。如果多项式是用系数的表示方法，$C(x)=A(x)*B(x)$，那么$c_k=\sum_{j=0}^ka_jb_{k-j}$。乘法的复杂度是$O(n^2)$。

但是如果用sample的表示方法。用sample的点序列$[(x_0,y_0),(x_1,y_1),...,(x_{n-1},y_{n-1})]$表示多项式。乘法的时间复杂度是$O(n)$，因为对于同样的采样点x，只用相乘y的值就可以了。

如果我们可以在少于$O(n^2)$的时间内，从系数转换到sample的形式，就可以得到快速的多项式计算。

DFT可以让我们在系数和采样之间转换。通过选择特殊的采样点`complex roots of unity`，就可以得到$O(nlgn)$。

![](/assets/mit2.2.png)

#### 快速傅里叶变换

快速傅里叶变换应用了分治法将多项式分为奇数项和偶数项。从而得到了一个$x\to x^2$的一个递归式。再通过集合的崩塌（collapsing），比如-1和1的平方都是1。减少算法的复杂度。

$$A_{even}(x)=\sum_{k=0}^{n/2-1}a_{2k}x^k = <a_0,a_2,a4,...>$$

$$A_{odd}(x)=\sum_{k=0}^{n/2-1}a_{2k}x^k=<a_1,a_3,a_5,...>$$



### van Emde Boas Trees (V树)

对范围为u的不重复整数，执行insert，delete，successor操作，时间复杂度为$O(lglgu)$。一个应用是对路由表的查询，大致流程是给定ip可以转换成$2^{32}$的一个整数，然后查询匹配项的下一项，下一项。

通过对基本数据结构的一步步扩展，就可以得到V树的数据结构。

首先是位图和cluster。位图可以快速查找指定项，但是successor操作，可能需要遍历整个位图。所以将整个位图按照$\sqrt u$的大小，分成不同过的cluster，比如下图标示0到3是否有数据，加快successor操作，successor的复杂度变为$O(\sqrt u)$

![](/assets/mit2.1.png)

#### 递归

这一步就很精妙了，将数据结构递归起来。
- V.cluster[i] 是一个size为$\sqrt u$的V
- V.summary 一个size为$\sqrt u$的V
```python
def successor(V,x):
    i = high(x)
    j = successor(v.cluster[i],j)
    if j == int.max:
        i = successor(v.summary,i)
        j = successor(v.cluster[i],-infinit)
    return index(i,j)
```
我们如果能把$T(u)=3T(\sqrt u)+O(1)$的递归式变为$T(u)=T(\sqrt u)+O(1)$就可以得到$O(lglgu)$的复杂度。

通过存储min和max值，以及lazy init等。就可以做到。
